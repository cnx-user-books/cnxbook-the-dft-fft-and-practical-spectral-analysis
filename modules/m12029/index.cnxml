<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">
  <title>Running FFT</title>
  <metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>13264275-0f9d-4838-b192-f1b04b116b27</md:uuid>
</metadata>

  <content>
    <para id="para1">Some applications need <link document="m12032" target-id="DFTequation">DFT</link> frequencies
    of the most recent <m:math><m:ci>N</m:ci></m:math> samples on an ongoing basis.
    One example is <link url="http://en.wikipedia.org/wiki/DTMF">DTMF</link>, or touch-tone
    telephone dialing, in which a detection circuit must constantly monitor the line for
    two simultaneous frequencies indicating that a telephone button is depressed.
    In such cases, most of the data in each successive block of samples is the same,
    and it is possible to efficiently update the DFT value from the previous sample
    to compute that of the current sample.
    <link target-id="fig1"/> illustrates successive length-4 blocks of data for which
    successive DFT values may be needed.
    The <term>running FFT</term> algorithm described here can be used to compute
    successive DFT values at a cost of only two complex multiplies and additions
    per DFT frequency.
</para>
    <figure id="fig1">
      <media id="idp9815136" alt=""><image src="../../media/image3-7ca6.png" mime-type="image/png"/><image for="pdf" src="../../media/RunningFFT_fig1.eps" mime-type="application/postscript"/></media>
      <caption>The running FFT efficiently computes DFT values for successive
        overlapped blocks of samples.
      </caption>
    </figure>
    <para id="para2">The running FFT algorithm is derived by expressing each DFT sample,
        <m:math>
          <m:apply>
	    <m:ci type="fn">
	      <m:msub>
		<m:mi>X</m:mi>
                  <m:mrow>
		  <m:mi>n</m:mi>
		  <m:mo>+</m:mo>
		  <m:mn>1</m:mn>
		</m:mrow>
	      </m:msub>
	    </m:ci>
	    <m:ci>
	      <m:msub>
		<m:mi>ω</m:mi>
		<m:mi>k</m:mi>
	      </m:msub>
	    </m:ci>
	  </m:apply>
        </m:math>,
      for the next block at time
      <m:math>
        <m:apply>
          <m:plus/>
            <m:ci>n</m:ci>
            <m:cn>1</m:cn>
        </m:apply>
      </m:math>
      in terms of the previous value,
<m:math>
<m:apply>
	    <m:ci type="fn">
	      <m:msub>
		<m:mi>X</m:mi>
		<m:mi>n</m:mi>
	      </m:msub>
	    </m:ci>
	    <m:ci>
	      <m:msub>
		<m:mi>ω</m:mi>
		<m:mi>k</m:mi>
	      </m:msub>
	    </m:ci>
	  </m:apply>
</m:math>,
 at time <m:math><m:ci>n</m:ci></m:math>.
      <m:math display="block">
	<m:apply>
	  <m:eq/>
	  <m:apply>
	    <m:ci type="fn">
	      <m:msub>
		<m:mi>X</m:mi>
		<m:mi>n</m:mi>
	      </m:msub>
	    </m:ci>
	    <m:ci>
	      <m:msub>
		<m:mi>ω</m:mi>
		<m:mi>k</m:mi>
	      </m:msub>
	    </m:ci>
	  </m:apply>
	  <m:apply>
	    <m:sum/>
	    <m:bvar>
	      <m:ci>p</m:ci>
	    </m:bvar>
	    <m:uplimit>
	      <m:apply>
		<m:minus/>
		<m:ci>N</m:ci>
		<m:cn>1</m:cn>
	      </m:apply>
	    </m:uplimit>
	    <m:lowlimit>
	      <m:cn>0</m:cn>
	    </m:lowlimit>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:ci type="fn">x</m:ci>
		<m:apply>
		  <m:minus/>
		  <m:ci>n</m:ci>
		  <m:ci>p</m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:exp/>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:times/>
		    <m:imaginaryi/>
		    <m:ci>
		      <m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub>
		    </m:ci>
		    <m:ci>p</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:apply>
      </m:math>
      <m:math display="block">
	<m:apply>
	  <m:eq/>
	  <m:apply>
	    <m:ci type="fn">
	      <m:msub>
		<m:mi>X</m:mi>
		<m:mrow>
		  <m:mi>n</m:mi>
		  <m:mo>+</m:mo>
		  <m:mn>1</m:mn>
		</m:mrow>
	      </m:msub>
	    </m:ci>
	    <m:ci>
	      <m:msub>
		<m:mi>ω</m:mi>
		<m:mi>k</m:mi>
	      </m:msub>
	    </m:ci>
	  </m:apply>
	  <m:apply>
	    <m:sum/>
	    <m:bvar>
	      <m:ci>p</m:ci>
	    </m:bvar>
	    <m:uplimit>
	      <m:apply>
		<m:minus/>
		<m:ci>N</m:ci>
		<m:cn>1</m:cn>
	      </m:apply>
	    </m:uplimit>
	    <m:lowlimit>
	      <m:cn>0</m:cn>
	    </m:lowlimit>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:ci type="fn">x</m:ci>
		<m:apply>
		  <m:plus/>
		  <m:ci>n</m:ci>
		  <m:apply>
		    <m:minus/>
		    <m:cn>1</m:cn>
		    <m:ci>p</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:exp/>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:times/>
		    <m:imaginaryi/>
		    <m:ci>
		      <m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub>
		    </m:ci>
		    <m:ci>p</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:apply>
      </m:math>
      Let <m:math>
	<m:apply>
	  <m:eq/>
	  <m:ci>q</m:ci>
	  <m:apply>
	    <m:minus/>
	    <m:ci>p</m:ci>
	    <m:cn>1</m:cn>
	  </m:apply>
	</m:apply>
      </m:math>:
       <m:math display="block">
	<m:apply>
	  <m:eq/>
	  <m:apply>
	    <m:ci type="fn">
	      <m:msub>
		<m:mi>X</m:mi>
		<m:mrow>
		  <m:mi>n</m:mi>
		  <m:mo>+</m:mo>
		  <m:mn>1</m:mn>
		</m:mrow>
	      </m:msub>
	    </m:ci>
	    <m:ci>
	      <m:msub>
		<m:mi>ω</m:mi>
		<m:mi>k</m:mi>
	      </m:msub>
	    </m:ci>
	  </m:apply>
	  <m:apply>
	    <m:sum/>
	    <m:bvar>
	      <m:ci>q</m:ci>
	    </m:bvar>
	    <m:uplimit>
	      <m:apply>
		<m:minus/>
		<m:ci>N</m:ci>
		<m:cn>2</m:cn>
	      </m:apply>
	    </m:uplimit>
	    <m:lowlimit>
	      <m:apply>
		<m:minus/>
		<m:cn>1</m:cn>
	      </m:apply>
	    </m:lowlimit>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:ci type="fn">x</m:ci>
		<m:apply>
		  <m:minus/>
		  <m:ci>n</m:ci>
		  <m:ci>q</m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:exp/>
		<m:apply>
		  <m:minus/>
		  <m:apply>
		    <m:times/>
		    <m:imaginaryi/>
		    <m:ci>
		      <m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub>
		    </m:ci>
		    <m:apply>
		      <m:minus/>
		      <m:ci>q</m:ci>
		      <m:cn>1</m:cn>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	  <m:apply>
	    <m:plus/>
	    <m:apply>
	      <m:times/>
	      <m:apply>
		<m:exp/>
		<m:apply>
		  <m:times/>
		  <m:imaginaryi/>
		  <m:ci>
		    <m:msub>
		      <m:mi>ω</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub>
		  </m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:sum/>
		<m:bvar>
		  <m:ci>q</m:ci>
		</m:bvar>
		<m:uplimit>
		  <m:apply>
		    <m:minus/>
		    <m:ci>N</m:ci>
		    <m:cn>2</m:cn>
		  </m:apply>
		</m:uplimit>
		<m:lowlimit>
		  <m:cn>0</m:cn>
		</m:lowlimit>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:ci type="fn">x</m:ci>
		    <m:apply>
		      <m:minus/>
		      <m:ci>n</m:ci>
		      <m:ci>q</m:ci>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:exp/>
		    <m:apply>
		      <m:minus/>
		      <m:apply>
			<m:times/>
			<m:imaginaryi/>
			<m:ci>
			  <m:msub>
			    <m:mi>ω</m:mi>
			    <m:mi>k</m:mi>
			  </m:msub>
			</m:ci>
                        <m:ci>q</m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	    <m:apply>
	      <m:ci type="fn">x</m:ci>
	      <m:apply>
		<m:plus/>
		<m:ci>n</m:ci>
		<m:cn>1</m:cn>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:apply>
      </m:math>
      Now let's add and subtract
      <m:math>
	<m:apply>
	  <m:times/>
	  <m:apply>
	    <m:exp/>
	    <m:apply>
	      <m:minus/>
	      <m:apply>
		<m:times/>
		<m:imaginaryi/>
		<m:ci>
		  <m:msub>
		    <m:mi>ω</m:mi>
		    <m:mi>k</m:mi>
		  </m:msub>
		</m:ci>
		<m:apply>
		  <m:minus/>
		  <m:ci>N</m:ci>
		  <m:cn>2</m:cn>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	  <m:apply>
	    <m:ci type="fn">x</m:ci>
	    <m:apply>
	      <m:plus/>
	      <m:apply>
		<m:minus/>
		<m:ci>n</m:ci>
		<m:ci>N</m:ci>
	      </m:apply>
	      <m:cn>1</m:cn>
	    </m:apply>
	  </m:apply>
	</m:apply>
      </m:math>:
      <equation id="eq1">
	<m:math>
	  <m:apply>
	    <m:eq/>
	    <m:apply>
	      <m:ci type="fn">
		<m:msub>
		  <m:mi>X</m:mi>
		  <m:mrow>
		    <m:mi>n</m:mi>
		    <m:mo>+</m:mo>
		    <m:mn>1</m:mn>
		  </m:mrow>
		</m:msub>
	      </m:ci>
	      <m:ci>
		<m:msub>
		  <m:mi>ω</m:mi>
		  <m:mi>k</m:mi>
		</m:msub>
	      </m:ci>  
	    </m:apply>
	    <m:apply>
	      <m:plus/>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:exp/>
		  <m:apply>
		    <m:times/>
		    <m:imaginaryi/>
		    <m:ci>
		      <m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub>
		    </m:ci>
		  </m:apply>
		</m:apply>
	       	<m:apply>
		  <m:sum/>
		  <m:bvar>
		    <m:ci>q</m:ci>
		  </m:bvar>
		  <m:uplimit>
		    <m:apply>
		      <m:minus/>
		      <m:ci>N</m:ci>
		      <m:cn>2</m:cn>
		    </m:apply>
		  </m:uplimit>
		  <m:lowlimit>
		    <m:cn>0</m:cn>
		  </m:lowlimit>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:ci type="fn">x</m:ci>
		      <m:apply>
			<m:minus/>
			<m:ci>n</m:ci>
			<m:ci>q</m:ci>
		      </m:apply>
		    </m:apply>
		    <m:apply>
		      <m:exp/>
		      <m:apply>
			<m:minus/>
		     	<m:apply>
			  <m:times/>
			  <m:imaginaryi/>
			  <m:ci>
			    <m:msub>
			      <m:mi>ω</m:mi>
			      <m:mi>k</m:mi>
			    </m:msub>
			  </m:ci>
			  <m:ci>q</m:ci>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:minus/>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:exp/>
		    <m:apply>
		      <m:times/>
		      <m:imaginaryi/>
			<m:ci>
		  	<m:msub>
			  <m:mi>ω</m:mi>
			  <m:mi>k</m:mi>
			</m:msub>
		      </m:ci>
		    </m:apply>
		  </m:apply>
		    <m:apply>
		    <m:ci type="fn">x</m:ci>
		    <m:apply>
		      <m:minus/>
		      <m:ci>n</m:ci>
		      <m:apply>
			<m:minus/>
			<m:ci>N</m:ci>
			<m:cn>1</m:cn>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:exp/>
		    <m:apply>
		      <m:minus/>
		      <m:apply>
			<m:times/>
			<m:imaginaryi/>
			<m:ci>
			  <m:msub>
			    <m:mi>ω</m:mi>
			    <m:mi>k</m:mi>
			  </m:msub>
			</m:ci>
			<m:apply>
			  <m:minus/>
			  <m:ci>N</m:ci>
			  <m:cn>1</m:cn>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:exp/>
		    <m:apply>
		      <m:minus/>
		      <m:apply>
			<m:times/>
			<m:imaginaryi/>
			<m:ci>
			  <m:msub>
			    <m:mi>ω</m:mi>
			    <m:mi>k</m:mi>
			  </m:msub>
			</m:ci>
			<m:apply>
			  <m:minus/>
			  <m:ci>N</m:ci>
			  <m:cn>2</m:cn>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		    <m:apply>
		    <m:ci type="fn">x</m:ci>
		    <m:apply>
		      <m:plus/>
		      <m:apply>
			<m:minus/>
			<m:ci>n</m:ci>
			<m:ci>N</m:ci>
		      </m:apply>
		      <m:cn>1</m:cn>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:ci type="fn">x</m:ci>
		<m:apply>
		  <m:plus/>
		  <m:ci>n</m:ci>
		  <m:cn>1</m:cn>
		</m:apply>
	      </m:apply>
	    </m:apply>
	    <m:apply>
	      <m:plus/>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:exp/>
		  <m:apply>
		    <m:times/>
		    <m:imaginaryi/>
		    <m:ci>
		      <m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub>
		    </m:ci>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:sum/>
		  <m:bvar>
		    <m:ci>q</m:ci>
		  </m:bvar>
		  <m:uplimit>
		    <m:apply>
		      <m:minus/>
		      <m:ci>N</m:ci>
		      <m:cn>1</m:cn>
		    </m:apply>
		  </m:uplimit>
		  <m:lowlimit>
		    <m:cn>0</m:cn>
		  </m:lowlimit>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:ci type="fn">x</m:ci>
		      <m:apply>
			<m:minus/>
			<m:ci>n</m:ci>
			<m:ci>q</m:ci>
		      </m:apply>
		    </m:apply>
		    <m:apply>
		      <m:exp/>
		      <m:apply>
			<m:minus/>
			<m:apply>
			  <m:times/>
			  <m:imaginaryi/>
			  <m:ci>
			    <m:msub>
			      <m:mi>ω</m:mi>
			      <m:mi>k</m:mi>
			    </m:msub>
			  </m:ci>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:minus/>
		<m:apply>
		  <m:ci type="fn">x</m:ci>
		  <m:apply>
		    <m:plus/>
		    <m:ci>n</m:ci>
		    <m:cn>1</m:cn>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:exp/>
		    <m:apply>
		      <m:minus/>
		      <m:apply>
			<m:times/>
			<m:imaginaryi/>
			<m:ci>
			  <m:msub>
			    <m:mi>ω</m:mi>
			    <m:mi>k</m:mi>
			  </m:msub>
			</m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">x</m:ci>
		    <m:apply>
		      <m:plus/>
		      <m:apply>
			<m:minus/>
			<m:ci>n</m:ci>
			<m:ci>N</m:ci>
		      </m:apply>
		      <m:cn>1</m:cn>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	    <m:apply>
	      <m:plus/>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:exp/>
		  <m:apply>
		    <m:times/>
		    <m:imaginaryi/>
		    <m:ci>
		      <m:msub>
			<m:mi>ω</m:mi>
			<m:mi>k</m:mi>
		      </m:msub>
		    </m:ci>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:ci type="fn">
		    <m:msub>
		      <m:mi>X</m:mi>
		      <m:mi>n</m:mi>
		    </m:msub>
		  </m:ci>
		  <m:ci>
		    <m:msub>
		      <m:mi>ω</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub>
		  </m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:minus/>
		<m:apply>
		  <m:ci type="fn">x</m:ci>
		  <m:apply>
		    <m:plus/>
		    <m:ci>n</m:ci>
		    <m:cn>1</m:cn>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:exp/>
		    <m:apply>
		      <m:minus/>
		      <m:apply>
			<m:times/>
			<m:imaginaryi/>
			<m:ci>
			  <m:msub>
			    <m:mi>ω</m:mi>
			    <m:mi>k</m:mi>
			  </m:msub>
			</m:ci>
			<m:apply>
			  <m:minus/>
			  <m:ci>N</m:ci>
			  <m:cn>2</m:cn>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">x</m:ci>
		    <m:apply>
		      <m:plus/>
		      <m:apply>
			<m:minus/>
			<m:ci>n</m:ci>
			<m:ci>N</m:ci>
		      </m:apply>
		      <m:cn>1</m:cn>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:apply>
	</m:math>
      </equation>
      This running FFT algorithm requires only two complex multiplies and adds
      per update, rather than N if each DFT value were recomputed according
      to the DFT equation.
      Another advantage of this algorithm is that it works for 
      <emphasis>any</emphasis> 
      <m:math>
	<m:ci>
	  <m:msub>
	    <m:mi>ω</m:mi>
	    <m:mi>k</m:mi>
	  </m:msub>
	</m:ci>
      </m:math>,
      rather than just the standard DFT frequencies.
      This can make it advantageous for applications, such as DTMF detection,
      where only a few arbitrary frequencies are needed.
    </para>
    <para id="isfilter">
      Successive computation of a specific DFT frequency for overlapped blocks
      can also be thought of as a length-<m:math><m:ci>N</m:ci></m:math>
      <link document="col10285">FIR filter</link>.
      The running FFT is an efficient recursive implementation of this
      filter for this special case.
      <link target-id="fig2"/> shows a block diagram of the running FFT
      algorithm.
      The running FFT is one way to compute <link document="m12771">DFT filterbanks</link>.
      If a window other than rectangular is desired, a running FFT
      requires either a fast recursive implementation of the corresponding
      windowed, modulated impulse response, or it must have few non-zero
      coefficients so that it can be applied after the running FFT update
      via frequency-domain convolution.
      <link document="m12032" target-id="windowing">DFT-symmmetric raised-cosine windows</link> are an example.
    </para>
    <figure id="fig2">
      <media id="idp14122672" alt=""><image src="../../media/image4-54f0.png" mime-type="image/png"/><image for="pdf" src="../../media/RunningFFT_fig2.eps" mime-type="application/postscript"/></media>
      <caption>Block diagram of the running FFT computation, implemented
        as a recursive filter
      </caption>
    </figure>
    
  </content>
  
</document>